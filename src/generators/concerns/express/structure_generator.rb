module Tenant
  module ExpressStructureGenerator
    def create_directory_structure(db_type)
      # Create base directories
      if @language.to_s.downcase == "typescript"
        # TypeScript project structure
        directories = [
          "#{@express_path}/src/controllers",
          "#{@express_path}/src/models",
          "#{@express_path}/src/routes",
          "#{@express_path}/src/middleware",
          "#{@express_path}/src/utils",
          "#{@express_path}/src/types",
          "#{@express_path}/dist"
        ]
      else
        # JavaScript project structure
        directories = [
          "#{@express_path}/controllers",
          "#{@express_path}/models",
          "#{@express_path}/routes",
          "#{@express_path}/middleware",
          "#{@express_path}/utils"
        ]
      end
      
      # Create directories
      directories.each do |dir|
        FileUtils.mkdir_p(dir)
      end
      
      # Create .env file with database connection string
      env_content = get_database_env_content(db_type)
      env_content += "PORT=3000\n"
      File.write("#{@express_path}/.env", env_content)
      
      # Create README.md
      readme_content = "# Express Application\n\n"
      readme_content += "This is an Express.js application generated by Dwelling"
      readme_content += " using #{@language.capitalize}.\n\n"
      readme_content += get_database_readme_content(db_type)
      readme_content += "## Getting Started\n\n"
      readme_content += "1. Install dependencies: `npm install`\n"
      
      if @language.to_s.downcase == "typescript"
        readme_content += "2. Build the application: `npm run build`\n"
        readme_content += "3. Start the server: `npm start` or `npm run dev` for development\n"
      else
        readme_content += "2. Start the server: `npm start` or `npm run dev` for development\n"
      end
      
      readme_content += get_database_setup_steps(db_type)
      
      File.write("#{@express_path}/README.md", readme_content)
      
      # Create .gitignore
      gitignore_content = <<~GITIGNORE
        node_modules/
        .env
        npm-debug.log
        yarn-error.log
        .DS_Store
        #{@language.to_s.downcase == "typescript" ? "dist/" : ""}
      GITIGNORE
      
      File.write("#{@express_path}/.gitignore", gitignore_content)
    end
    
    def create_app_js(db_type)
      # Determine file extension and path based on language
      file_ext = @language.to_s.downcase == "typescript" ? "ts" : "js"
      app_path = @language.to_s.downcase == "typescript" ? "#{@express_path}/src/app.#{file_ext}" : "#{@express_path}/app.#{file_ext}"
      
      # Common imports with appropriate syntax
      if @language.to_s.downcase == "typescript"
        app_content = <<~TS
          import dotenv from 'dotenv';
          import express, { Express, Request, Response, NextFunction } from 'express';
          import bodyParser from 'body-parser';
          import cors from 'cors';
          
          dotenv.config();
          
          const app: Express = express();
          
          // Middleware
          app.use(cors());
          app.use(bodyParser.json());
          app.use(bodyParser.urlencoded({ extended: true }));
          
          #{get_database_connection_code_ts(db_type)}
          
          // Routes
          // Route imports will be added here during route generation
          
          // Default route
          app.get('/', (req: Request, res: Response) => {
            res.json({ message: 'Welcome to the Express API' });
          });
          
          // Start server
          const PORT: number = parseInt(process.env.PORT || '3000', 10);
          app.listen(PORT, () => {
            console.log(`Server is running on port ${PORT}`);
          });
          
          export default app;
        TS
      else
        app_content = <<~JS
          require('dotenv').config();
          const express = require('express');
          const bodyParser = require('body-parser');
          const cors = require('cors');
          
          const app = express();
          
          // Middleware
          app.use(cors());
          app.use(bodyParser.json());
          app.use(bodyParser.urlencoded({ extended: true }));
          
          #{get_database_connection_code(db_type)}
          
          // Routes
          // Route imports will be added here during route generation
          
          // Default route
          app.get('/', (req, res) => {
            res.json({ message: 'Welcome to the Express API' });
          });
          
          // Start server
          const PORT = process.env.PORT || 3000;
          app.listen(PORT, () => {
            console.log(`Server is running on port ${PORT}`);
          });
          
          module.exports = app;
        JS
      end
      
      File.write(app_path, app_content)
    end
    
    def create_middleware_files
      # Determine file extension and base path based on language
      file_ext = @language.to_s.downcase == "typescript" ? "ts" : "js"
      base_path = @language.to_s.downcase == "typescript" ? "#{@express_path}/src" : @express_path
      
      # Create error handling middleware
      if @language.to_s.downcase == "typescript"
        error_handler = <<~TS
          import { Request, Response, NextFunction } from 'express';

          interface ErrorWithStatusCode extends Error {
            statusCode?: number;
          }

          // Error handling middleware
          const errorHandler = (err: ErrorWithStatusCode, req: Request, res: Response, next: NextFunction): void => {
            const statusCode = err.statusCode || 500;
            res.status(statusCode).json({
              status: 'error',
              statusCode,
              message: err.message,
              stack: process.env.NODE_ENV === 'production' ? 'ðŸ¥ž' : err.stack
            });
          };
          
          export default errorHandler;
        TS
      else
        error_handler = <<~JS
          // Error handling middleware
          const errorHandler = (err, req, res, next) => {
            const statusCode = err.statusCode || 500;
            res.status(statusCode).json({
              status: 'error',
              statusCode,
              message: err.message,
              stack: process.env.NODE_ENV === 'production' ? 'ðŸ¥ž' : err.stack
            });
          };
          
          module.exports = errorHandler;
        JS
      end
      
      File.write("#{base_path}/middleware/error_handler.#{file_ext}", error_handler)
      
      # Create authentication middleware template
      if @language.to_s.downcase == "typescript"
        auth_middleware = <<~TS
          import { Request, Response, NextFunction } from 'express';

          // Authentication middleware
          const authMiddleware = (req: Request, res: Response, next: NextFunction): void => {
            // TODO: Implement authentication logic
            // This is a placeholder for authentication middleware
            next();
          };
          
          export default authMiddleware;
        TS
      else
        auth_middleware = <<~JS
          // Authentication middleware
          const authMiddleware = (req, res, next) => {
            // TODO: Implement authentication logic
            // This is a placeholder for authentication middleware
            next();
          };
          
          module.exports = authMiddleware;
        JS
      end
      
      File.write("#{base_path}/middleware/auth.#{file_ext}", auth_middleware)
    end
    
    # Helper method for TypeScript database connection code
    def get_database_connection_code_ts(db_type)
      case db_type.to_s.downcase
      when 'sequelize', 'sql', 'mysql', 'postgres', 'postgresql'
        <<~TS
          import { Sequelize } from 'sequelize';

          // Database connection
          const sequelize = new Sequelize(process.env.DATABASE_URL || 'postgres://postgres:postgres@localhost:5432/express_app_development', {
            dialect: '#{db_type.to_s.downcase == 'mysql' ? 'mysql' : 'postgres'}',
            logging: false
          });

          // Test database connection
          (async () => {
            try {
              await sequelize.authenticate();
              console.log('Database connection has been established successfully.');
            } catch (error) {
              console.error('Unable to connect to the database:', error);
            }
          })();
        TS
      when 'prisma'
        <<~TS
          import { PrismaClient } from '@prisma/client';

          // Initialize Prisma client
          const prisma = new PrismaClient();

          // Test database connection
          (async () => {
            try {
              await prisma.$connect();
              console.log('Database connection has been established successfully.');
            } catch (error) {
              console.error('Unable to connect to the database:', error);
            }
          })();
        TS
      else # Default to MongoDB
        <<~TS
          import mongoose from 'mongoose';

          // Database connection
          const MONGODB_URI: string = process.env.MONGODB_URI || 'mongodb://localhost:27017/express-app';

          mongoose.connect(MONGODB_URI)
            .then(() => console.log('Connected to MongoDB'))
            .catch(err => console.error('Could not connect to MongoDB', err));
        TS
      end
    end
  end
end 